<?php

namespace TaskApp\Widgets;

use Illuminate\Support\Facades\Event;
use TaskApp\DB\StoreTempState;
use TaskApp\Classes\StoreTempTag;
use TaskApp\Models\Task;


/**
 *  |--------------------------------------------------------------------------
 *  |   You can use the below snippets to override the defaults.
 *  |====== Remove this doc block if you don't need it ========
 *  |--------------------------------------------------------------------------
 *  | public $contextAs = '$data'; (default : '$data')
 *  | public $controller = '\App\ClassPath\ُSomeClass@someMethod'; (optional)
 *  | public $presenter = \App\ClassPath\WidgetPresenter::class; (optional)
 *  | public $minifyOutput = true; (use it to override the default value in config file)
 *  | public $cacheTags = []; (optional) (Available for all cache driver)
 *  | public $cacheLifeTime = 0;   (use it to override the default value in config file)
 *  | public $cacheView = false; You may only cache the controller result. (default : true)
 *  | public $template; (optional) (By default it looks for the view file generated by artisan)
 *  |--------------------------------------------------------------------------
 */
class TaskList
{

    public $template = 'Task::TaskListView';


    public function data($state, $tab)
    {
        $userId = auth()->id();
        $query = Task::query()->where('user_id', $userId);

        $state && $query->hasActiveTags('state', ['value' => $state]);

        ($state == 5) && $query->orHasNotActiveTags('state');

        return ['tasks' => $query->get(), 'tab' => $tab];
    }

    /**
     * If the widget output depends on query strings you should return key names.
     * otherwise you get undesired results out of the cache store. for example:
     * example.com/product?page=1 and you use the page number in your db query
     * or if you want it to be separated for each user: return auth()->id();
     */
    public function cacheKey($args)
    {
        $userId = auth()->id();
        $dateId = now()->day . now()->month . now()->year;
        $state = $args[0]['state'] ?? 'all';
        return 'task_list_' . $userId . '_' . $state . $dateId;
    }

    public static function expireCache()
    {
        $fb = self::expireThisCache();
//        Task::created($fb);
//        Task::deleting($fb);
    }

    /**
     * @return \Closure
     */
    private static function expireThisCache(): \Closure
    {
        $fb = function ($task) {
            $userId = auth()->id();
            $dateId = now()->day . now()->month . now()->year;
            $state = StoreTempState::getState($task);
            $key = 'task_list_' . $userId . '_' . $state . $dateId;

            cache()->forget($key);

            $key = 'task_list_' . $userId . '_' . 'all' . $dateId;


            cache()->forget($key);
        };
        return $fb;
    }
}
